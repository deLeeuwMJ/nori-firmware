/*
    This is a backed-up version of working CPP code to interface with LCD Screen and render.
*/

#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_gc9a01.h"
#include "lvgl.h"
#include "esp_lvgl_port.h"

#define TEST_LCD_H_RES          (240)
#define TEST_LCD_V_RES          (240)
#define TEST_DELAY_TIME_MS      (3000)

static const char *TAG = "main";

// FreeRTOS is depended on calling a c app_main, hence extern "C"
extern "C" void app_main(void) {

    /*
     * SETUP SPI BUS
     */
    ESP_LOGI(TAG, "Initialize SPI bus");
    const spi_bus_config_t buscfg = {
        .mosi_io_num = GPIO_NUM_11,
        .miso_io_num = -1,
        .sclk_io_num = GPIO_NUM_10,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = TEST_LCD_H_RES * 80 * sizeof(uint16_t),
    };
    ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO));

    /*
     * SETUP LCD PANEL
     */
    ESP_LOGI(TAG, "Install panel IO");
    esp_lcd_panel_io_handle_t io_handle = NULL;
    const esp_lcd_panel_io_spi_config_t io_config = {
        .cs_gpio_num = GPIO_NUM_9,
        .dc_gpio_num = GPIO_NUM_8,
        .spi_mode = 0,
        .pclk_hz = (40 * 1000 * 1000), // GC9A01 can often run faster
        .trans_queue_depth = 10,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)SPI2_HOST, &io_config, &io_handle));

    esp_lcd_panel_handle_t lcd_panel_handle = NULL;
    const esp_lcd_panel_dev_config_t panel_config = {
        .reset_gpio_num = GPIO_NUM_14,
        .rgb_endian = LCD_RGB_ENDIAN_BGR,
        .bits_per_pixel = 16,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_gc9a01(io_handle, &panel_config, &lcd_panel_handle));

    // Configure backlight
    gpio_config_t bk_gpio_config = {
        .pin_bit_mask = 1ULL << GPIO_NUM_2,
        .mode = GPIO_MODE_OUTPUT
    };
    ESP_ERROR_CHECK(gpio_config(&bk_gpio_config));

    // Reset, Init, and Turn on Display
    ESP_ERROR_CHECK(esp_lcd_panel_reset(lcd_panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_init(lcd_panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_invert_color(lcd_panel_handle, true));
    ESP_ERROR_CHECK(esp_lcd_panel_mirror(lcd_panel_handle, false, false));
    ESP_ERROR_CHECK(esp_lcd_panel_disp_on_off(lcd_panel_handle, true));
    gpio_set_level(GPIO_NUM_2, 1); // Backlight on

    /*
     * SETUP LVGL
     */
    ESP_LOGI(TAG, "Initialize LVGL");
    const lvgl_port_cfg_t lvgl_cfg = ESP_LVGL_PORT_INIT_CONFIG();
    ESP_ERROR_CHECK(lvgl_port_init(&lvgl_cfg));

    const lvgl_port_display_cfg_t disp_cfg = {
        .io_handle = io_handle,
        .panel_handle = lcd_panel_handle,
        .buffer_size = TEST_LCD_H_RES * 40,
        .double_buffer = true,
        .hres = TEST_LCD_H_RES,
        .vres = TEST_LCD_V_RES,
        .monochrome = false,
        .rotation = {
            .swap_xy = false,
            .mirror_x = false,
            .mirror_y = false,
        },
        .flags = {
            .swap_bytes = true,
        }
    };
    lv_disp_t * disp_handle = lvgl_port_add_disp(&disp_cfg);

    /*
     * DRAW A COLOURED BOX
     */
    ESP_LOGI(TAG, "Displaying a coloured box");
    lvgl_port_lock(0);
    lv_obj_t * screen = lv_disp_get_scr_act(disp_handle);
    // Clear the screen to a solid color first to verify basic functionality
    lv_obj_set_style_bg_color(screen, lv_color_white(), LV_PART_MAIN);

    // Create the smaller box
    lv_obj_t * color_box = lv_obj_create(screen);
    lv_obj_set_size(color_box, 80, 80);
    lv_obj_center(color_box);
    lv_obj_set_style_bg_color(color_box, lv_palette_main(LV_PALETTE_BLUE), LV_PART_MAIN);
    lv_obj_set_style_border_width(color_box, 0, LV_PART_MAIN);
    lvgl_port_unlock();

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
